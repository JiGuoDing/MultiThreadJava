# `Synchronized` 关键字的用法
## *每个 `对象` 对应一把 `锁`*

## 使用场景

- `同步实例方法` 同步当前 **对象（示例）** 的实例方法，确保同一
时刻只有一个线程能够执行该方法。
- `同步类方法` 同步 **类级别** 的方法（静态方法），确保同一时刻
只有一个线程能执行该方法。
- `同步代码块` 同步代码块的方式提供 **更细粒度** 的锁，允许方法
中的某些部分进行同步。

### 1. 同步实例方法

当一个方法被 `synchronized` 修饰时，锁定的是当前对象实例。
每个线程只能获得当前对象的锁才能执行该方法。

```java
public class SynchronizedExample {
    // 同步实例方法
    public synchronized void method() {
        // 执行一些代码
        System.out.println("同步实例方法正在执行: " + Thread.currentThread().getName());
    }
}
```

### 2. 同步类方法

当方法被声明为静态方法并且使用 `synchronized` 修饰时，
锁定的是该类的类对象 `（Class）` 。
因此只能 一个线程一个线程地执行该方法。

```java
public class SynchronizedExample {
    // 同步类方法
    public static synchronized void staticMethod() {
        // 执行一些代码
        System.out.println("同步类方法正在执行: " + Thread.currentThread().getName());
    }
}
```

### 3. 同步代码块

`synchronized` 也可以用来修饰代码块。与同步方法相比，
同步代码块可以控制更加细粒度的锁定，能够提高性能。
在代码块中，我们可以 **指定锁定的对象**。

```java
public class SynchronizedExample {
    private final Object lock = new Object();

    public void method() {
        synchronized (lock) {  // 同步代码块
            // 执行一些代码
            System.out.println("同步代码块正在执行: " + Thread.currentThread().getName());
        }
    }
}
```

> 同步块：`synchronized(Obj) {}`  
> `Obj` 称为 **同步监视器** ，就是锁的是什么  
> `Obj` 可以是任何对象，但是推荐使用 **共享资源** 作为同步监视器  
> 同步方法中无需指定同步监视器，因为同步方法的监视器就是 `this`，
> 就是这个对象本身，或者是 `class`  
> **同步监视器** 的执的过程  
> 1. 第一个线程访问，锁定同步监视器，执行其中代码
> 2. 第二个线程访问，发现同步监视器被锁定，无法访问
> 3. 第一个线程访问完毕，解锁同步监视器
> 4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

## `synchronized` 的工作原理

`synchronized` 的工作原理基于 **对象锁** 和 **类锁**。
它通过使用内置锁来确保在 ***同一时刻***，
***只有一个线程*** 能够执行同步代码块或方法。

1. `锁定对象`：每个对象（包括类的 Class 对象）都有一个锁，
称为 监视器锁（monitor）。当一个线程访问同步方法或代码块时，
它必须获得该对象的锁。若该锁已被其他线程占用，
则其他线程需要等待该锁释放。
2. `阻塞与等待`：当一个线程请求获取对象锁时，
如果该锁已经被其他线程持有，该线程会被阻塞，
直到其他线程释放锁。释放锁时，
通常由 JVM 来选择一个等待的线程，让其获得锁并继续执行。

## `synchronized` 的使用注意事项

### **死锁（Deadlock)**
>在多线程编程中，死锁是一种非常常见的并发问题。
> 死锁指的是两个或更多线程在执行过程中因为竞争资源而造成一种相互等待的现象，
> 导致程序无法继续执行。 例如，线程A持有锁L1并等待获取锁L2，
> 线程B持有锁L2并等待获取锁L1，这种情况下，
> 两个线程就会陷入死锁。

`避免死锁的方法`
> - 确保线程按 **相同的顺序** 获得锁。
> - 使用 `tryLock()` 方法尝试获取锁，而不是一直等待。
> - 使用 `timeout` 设置获取锁的 **最大等待时间**。

### **不要在同步块中做 `I/O` 操作**
> `I/O` 操作往往是 **阻塞的**，若将 `I/O` 操作放入同步块中，
> 可能会导致其他线程长时间无法访问同步的资源，
> 从而影响并发性能。**尽量避免在同步块中** 进行 `I/O` 操作，
> 或将 `I/O` 操作与其他任务隔离。

## **`其他同步工具`**

> - **ReentrantLock**：  
ReentrantLock 是 `java.util.concurrent.locks` 包中的类，
提供了与 `synchronized` 类似的功能，但具有更多的功能，如尝试加锁、定时锁等。
> - **读写锁（`ReadWriteLock`）**：  
适用于读操作多于写操作的场景，可以通过 `ReadWriteLock` 来提高性能，
允许多个线程并发读取，只在写操作时加锁。
> - **CountDownLatch 和 CyclicBarrier**：  
这些工具适用于控制线程之间的协调、同步和等待特定事件的发生。
